<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Ball Pool (Real Physics)</title>
    <script src="https://cdn.tailwindcss.com"></script>
        <script>
        // --- GAME ENGINE (Matter.js) ---
        const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
              Bodies = Matter.Bodies, Composite = Matter.Composite, Events = Matter.Events,
              Vector = Matter.Vector, Body = Matter.Body;

        let engine, render, runner;
        let width = 800, height = 400; 
        let cueBall, balls = [];
        let isDragging = false, dragStart = null;
        let difficulty = 'easy';
        let userTurn = true;
        let gameActive = false;
        let mouseCurrent = { x: 0, y: 0 }; // Define globally

        // --- SETUP ---
        function initPhysics() {
            if(engine) { Matter.World.clear(engine.world); Matter.Engine.clear(engine); }
            const canvas = document.getElementById('pool-canvas');
            
            // FIX: Table Size Logic (Mobile Friendly)
            // Use 95% of screen width, but max 800px
            let screenW = window.innerWidth;
            if (screenW > 800) screenW = 800; // Cap max width
            
            width = screenW - 20; // Leave some margin
            height = width / 2;   // Keep 2:1 Aspect Ratio

            canvas.width = width; canvas.height = height;

            engine = Engine.create();
            engine.world.gravity.y = 0; 

            // Walls (Cushions)
            const wallOpts = { isStatic: true, render: { fillStyle: '#1a4d2e' }, restitution: 1 };
            const thick = 20;
            Composite.add(engine.world, [
                Bodies.rectangle(width/2, 0, width, thick, wallOpts), // Top
                Bodies.rectangle(width/2, height, width, thick, wallOpts), // Bottom
                Bodies.rectangle(width, height/2, thick, height, wallOpts), // Right
                Bodies.rectangle(0, height/2, thick, height, wallOpts) // Left
            ]);

            // FIX: Ball Physics (Faster & Bouncier)
            const ballSize = width / 50; // Slightly smaller balls for better movement
            const ballOpts = { 
                restitution: 0.95,  // More Bounciness (0-1)
                friction: 0.001,    // Less Friction on table
                frictionAir: 0.01,  // Less Air Resistance (Speed stays longer)
                density: 0.05 
            }; 
            
            // Cue Ball
            cueBall = Bodies.circle(width * 0.25, height / 2, ballSize, { ...ballOpts, render: { fillStyle: '#fff' }, label: 'cue' });
            Composite.add(engine.world, cueBall);

            // Rack (15 Balls)
            let startX = width * 0.75;
            let startY = height / 2;
            let rows = 5;
            let colors = ['#fdd835', '#1e88e5', '#e53935', '#8e24aa', '#fb8c00', '#43a047', '#8d6e63', '#212121', '#fdd835', '#1e88e5', '#e53935', '#8e24aa', '#fb8c00', '#43a047', '#8d6e63'];
            
            let ballIdx = 0;
            balls = []; // Clear old array
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j <= i; j++) {
                    let x = startX + i * (ballSize * 1.8);
                    let y = startY - (i * ballSize) + (j * ballSize * 2);
                    let color = colors[ballIdx % colors.length];
                    let ball = Bodies.circle(x, y, ballSize, { ...ballOpts, render: { fillStyle: color }, label: 'ball' });
                    Composite.add(engine.world, ball);
                    balls.push(ball);
                    ballIdx++;
                }
            }

            // Renderer
            render = Render.create({
                canvas: canvas,
                engine: engine,
                options: { width, height, wireframes: false, background: '#2e7d32' }
            });

            // Custom Drawing for Cue Stick
            Events.on(render, 'afterRender', function() {
                const ctx = render.context;
                if (isDragging && userTurn && isBallsStopped()) {
                    ctx.beginPath();
                    ctx.moveTo(cueBall.position.x, cueBall.position.y);
                    
                    // Visual line opposite to drag
                    const dx = cueBall.position.x - mouseCurrent.x;
                    const dy = cueBall.position.y - mouseCurrent.y;
                    
                    // Line length based on drag power (clamped)
                    ctx.lineTo(cueBall.position.x + dx * 2, cueBall.position.y + dy * 2);
                    
                    ctx.lineWidth = 6;
                    ctx.strokeStyle = 'white'; // Stick color
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
            });

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
            
            // Input Handling
            canvas.addEventListener('mousedown', handleInputStart);
            canvas.addEventListener('mousemove', handleInputMove);
            window.addEventListener('mouseup', handleInputEnd);
            
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInputStart(e.touches[0]); }, {passive: false});
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleInputMove(e.touches[0]); }, {passive: false});
            window.addEventListener('touchend', handleInputEnd);
        }

        function handleInputStart(e) {
            if (!userTurn || !isBallsStopped()) return;
            const rect = render.canvas.getBoundingClientRect();
            dragStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
            mouseCurrent = { x: dragStart.x, y: dragStart.y }; // Reset current
            isDragging = true;
        }

        function handleInputMove(e) {
            if (!isDragging) return;
            const rect = render.canvas.getBoundingClientRect();
            mouseCurrent = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function handleInputEnd(e) {
            if (!isDragging) return;
            isDragging = false;
            
            // FIX: Shot Power Increased
            const forceMultiplier = 0.00040; // Power badha di (pehle 0.00025 thi)
            
            const dx = dragStart.x - mouseCurrent.x;
            const dy = dragStart.y - mouseCurrent.y;
            
            // Min shot check (agar bohot dheere kheela to cancel)
            if (Math.abs(dx) < 5 && Math.abs(dy) < 5) return;

            // Apply force to cue ball
            Body.applyForce(cueBall, cueBall.position, { x: dx * forceMultiplier, y: dy * forceMultiplier });
            
            // End turn
            userTurn = false;
            document.getElementById('turn-text').innerText = "Bot Playing...";
            document.getElementById('turn-text').className = "text-red-400 font-bold";
            
            setTimeout(botTurnLogic, 2000); 
        }

        function isBallsStopped() {
            const threshold = 0.05; // Thoda strict threshold taaki game fast rahe
            if (cueBall.speed > threshold) return false;
            for (let b of balls) {
                if (b.speed > threshold) return false;
            }
            return true;
        }

        // --- BOT AI ---
        function botTurnLogic() {
            const checkInterval = setInterval(() => {
                if (isBallsStopped()) {
                    clearInterval(checkInterval);
                    executeBotShot();
                }
            }, 500);
        }

        function executeBotShot() {
            let target = balls[Math.floor(Math.random() * balls.length)]; 
            
            if (difficulty === 'hard') {
                let minDist = Infinity;
                balls.forEach(b => {
                    let d = Vector.magnitude(Vector.sub(b.position, cueBall.position));
                    if (d < minDist) { minDist = d; target = b; }
                });
            }

            if (!target) return; 

            let vec = Vector.sub(target.position, cueBall.position);
            let angle = Vector.angle(cueBall.position, target.position);
            
            let error = 0;
            if (difficulty === 'easy') error = (Math.random() - 0.5) * 0.4; 
            if (difficulty === 'medium') error = (Math.random() - 0.5) * 0.15; 
            
            // Bot Power
            let power = 0.025 + Math.random() * 0.015; 
            let forceVector = Vector.rotate({ x: power, y: 0 }, angle + error);
            
            Body.applyForce(cueBall, cueBall.position, forceVector);
            
            setTimeout(() => {
                const returnCheck = setInterval(() => {
                    if (isBallsStopped()) {
                        clearInterval(returnCheck);
                        userTurn = true;
                        document.getElementById('turn-text').innerText = "Your Turn (Drag to Shoot)";
                        document.getElementById('turn-text').className = "text-yellow-300 font-bold";
                    }
                }, 500);
            }, 1000);
        }

        // --- FLOW LOGIC ---
        function startToss(level) {
            difficulty = level;
            document.getElementById('menu-modal').classList.add('hidden');
            document.getElementById('toss-modal').classList.remove('hidden');
        }

        function playRPS(move) {
            const opts = ['rock', 'paper', 'scissors'];
            const botMove = opts[Math.floor(Math.random()*3)];
            const msg = document.getElementById('toss-msg');
            
            if (move === botMove) {
                msg.innerText = "Draw! Try again.";
                return;
            }
            
            let win = (move==='rock' && botMove==='scissors') || (move==='paper' && botMove==='rock') || (move==='scissors' && botMove==='paper');
            
            msg.innerText = win ? "You Won! You break." : "Bot Won! Bot breaks.";
            
            setTimeout(() => {
                document.getElementById('toss-modal').classList.add('hidden');
                document.getElementById('game-container').classList.remove('hidden');
                initPhysics();
                
                userTurn = win;
                const turnTxt = document.getElementById('turn-text');
                if(win) {
                     turnTxt.innerText = "Your Turn (Drag to Shoot)";
                     turnTxt.className = "text-yellow-300 font-bold";
                } else {
                     turnTxt.innerText = "Bot Playing...";
                     turnTxt.className = "text-red-400 font-bold";
                     setTimeout(executeBotShot, 1500); 
                }
            }, 1500);
        }
    </script>

</body>
</html>
